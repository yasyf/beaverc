Our implementation keeps track of allocated objects by having each allocation of a Value done by calling an allocation method on our `CollectedHeap` instance. Value classes inherit from `Collectable`, and take a `CollectedHeap` in the constructor; this is passed in by the `CollectedHeap` when `allocate()` is called. Each allocated Value is stored in a linked list within the `CollectedHeap` instance, and it is only removed from this list when the Value is garbage collected.

Memory usage is tracked as follows. The `CollectedHeap` has atomic methods to increase and decrease a count of the bytes used by the heap. This count is initialized to an estimate of the overhead of the class itself, plus the total physical memory used at the time just before it is instantiated. When Values are allocated, their contstructors call `increaseSize` with the result of their `size()` function. Each Value has a `size()` defined which estimates the size of the instance, taking into account static class size and the size of any dynamic members. This value is multiplied by a constant to make it an over-estimate. The `CollectedHeap` then has an over-estimate of the size of all allocated objects, and objects such as Records wil occasionally update the heap by incrementing this count when items are added (to account for the extra overhead of storing more pointers, etc). When objects are deallocated, the result of their current `size()` call is subtracted from the heap byte count.

Records have a `size()` method which returns the static size of the class, plus the total size in bytes of each of the `std::string` keys and the total number of bytes used to store each of the pointers (one per value in the Record). Strings use the size in bytes of the underlying buffer (based on `capacity()`).

Currently, garbage collection is triggered after any instruction where the size of the heap in bytes exceeds some threshold. This is checked in the `potentially_garbage_collect()` method called after every instruction, and currently the threshold is defined as a fixed fraction of the max heap size in bytes.
